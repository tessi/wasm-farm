// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[repr(u8)]
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
pub enum PlantType {
    Wheat,
    Grass,
}
impl ::core::fmt::Debug for PlantType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            PlantType::Wheat => f.debug_tuple("PlantType::Wheat").finish(),
            PlantType::Grass => f.debug_tuple("PlantType::Grass").finish(),
        }
    }
}
impl PlantType {
    #[doc(hidden)]
    pub unsafe fn _lift(val: u8) -> PlantType {
        if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
        }
        match val {
            0 => PlantType::Wheat,
            1 => PlantType::Grass,
            _ => panic!("invalid enum discriminant"),
        }
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct Plant {
    pub plant_type: PlantType,
    pub growth_stage: u32,
    pub growth_stage_max: u32,
}
impl ::core::fmt::Debug for Plant {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Plant")
            .field("plant-type", &self.plant_type)
            .field("growth-stage", &self.growth_stage)
            .field("growth-stage-max", &self.growth_stage_max)
            .finish()
    }
}
#[derive(Clone, Copy)]
pub enum Action {
    Idle,
    MoveLeft,
    MoveRight,
    MoveUp,
    MoveDown,
    Water,
    Seed(PlantType),
    Harvest,
}
impl ::core::fmt::Debug for Action {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            Action::Idle => f.debug_tuple("Action::Idle").finish(),
            Action::MoveLeft => f.debug_tuple("Action::MoveLeft").finish(),
            Action::MoveRight => f.debug_tuple("Action::MoveRight").finish(),
            Action::MoveUp => f.debug_tuple("Action::MoveUp").finish(),
            Action::MoveDown => f.debug_tuple("Action::MoveDown").finish(),
            Action::Water => f.debug_tuple("Action::Water").finish(),
            Action::Seed(e) => f.debug_tuple("Action::Seed").field(e).finish(),
            Action::Harvest => f.debug_tuple("Action::Harvest").finish(),
        }
    }
}
#[repr(u8)]
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
pub enum Sellable {
    Grass,
    Wheat,
}
impl ::core::fmt::Debug for Sellable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            Sellable::Grass => f.debug_tuple("Sellable::Grass").finish(),
            Sellable::Wheat => f.debug_tuple("Sellable::Wheat").finish(),
        }
    }
}
impl Sellable {
    #[doc(hidden)]
    pub unsafe fn _lift(val: u8) -> Sellable {
        if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
        }
        match val {
            0 => Sellable::Grass,
            1 => Sellable::Wheat,
            _ => panic!("invalid enum discriminant"),
        }
    }
}
#[repr(u8)]
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
pub enum Buyable {
    Water,
    Seeds,
    Energy,
}
impl ::core::fmt::Debug for Buyable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            Buyable::Water => f.debug_tuple("Buyable::Water").finish(),
            Buyable::Seeds => f.debug_tuple("Buyable::Seeds").finish(),
            Buyable::Energy => f.debug_tuple("Buyable::Energy").finish(),
        }
    }
}
impl Buyable {
    #[doc(hidden)]
    pub unsafe fn _lift(val: u8) -> Buyable {
        if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
        }
        match val {
            0 => Buyable::Water,
            1 => Buyable::Seeds,
            2 => Buyable::Energy,
            _ => panic!("invalid enum discriminant"),
        }
    }
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct Position {
    pub x: u32,
    pub y: u32,
}
impl ::core::fmt::Debug for Position {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Position").field("x", &self.x).field("y", &self.y).finish()
    }
}
#[derive(Clone)]
pub struct BotState {
    pub id: _rt::String,
    pub display_name: _rt::String,
    pub current_action: Action,
    pub energy: u32,
    pub water: u32,
    pub seeds: u32,
    pub position: Position,
}
impl ::core::fmt::Debug for BotState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("BotState")
            .field("id", &self.id)
            .field("display-name", &self.display_name)
            .field("current-action", &self.current_action)
            .field("energy", &self.energy)
            .field("water", &self.water)
            .field("seeds", &self.seeds)
            .field("position", &self.position)
            .finish()
    }
}
#[repr(u8)]
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
pub enum EntityType {
    Bot,
}
impl ::core::fmt::Debug for EntityType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            EntityType::Bot => f.debug_tuple("EntityType::Bot").finish(),
        }
    }
}
impl EntityType {
    #[doc(hidden)]
    pub unsafe fn _lift(val: u8) -> EntityType {
        if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
        }
        match val {
            0 => EntityType::Bot,
            _ => panic!("invalid enum discriminant"),
        }
    }
}
#[derive(Clone)]
pub struct Entity {
    pub id: _rt::String,
    pub display_name: Option<_rt::String>,
    pub entity_type: EntityType,
    pub position: Position,
}
impl ::core::fmt::Debug for Entity {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Entity")
            .field("id", &self.id)
            .field("display-name", &self.display_name)
            .field("entity-type", &self.entity_type)
            .field("position", &self.position)
            .finish()
    }
}
#[repr(u8)]
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
pub enum FieldType {
    Owned,
    Unowned,
    Stone,
}
impl ::core::fmt::Debug for FieldType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            FieldType::Owned => f.debug_tuple("FieldType::Owned").finish(),
            FieldType::Unowned => f.debug_tuple("FieldType::Unowned").finish(),
            FieldType::Stone => f.debug_tuple("FieldType::Stone").finish(),
        }
    }
}
impl FieldType {
    #[doc(hidden)]
    pub unsafe fn _lift(val: u8) -> FieldType {
        if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
        }
        match val {
            0 => FieldType::Owned,
            1 => FieldType::Unowned,
            2 => FieldType::Stone,
            _ => panic!("invalid enum discriminant"),
        }
    }
}
#[derive(Clone)]
pub struct Field {
    pub plant: Option<Plant>,
    pub watered: bool,
    pub field_type: FieldType,
    pub entities: _rt::Vec<Entity>,
}
impl ::core::fmt::Debug for Field {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Field")
            .field("plant", &self.plant)
            .field("watered", &self.watered)
            .field("field-type", &self.field_type)
            .field("entities", &self.entities)
            .finish()
    }
}
#[derive(Clone)]
pub struct FarmState {
    pub grass: u32,
    pub wheat: u32,
    pub fields_width: u32,
    pub fields_height: u32,
    pub fields: _rt::Vec<_rt::Vec<Field>>,
}
impl ::core::fmt::Debug for FarmState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("FarmState")
            .field("grass", &self.grass)
            .field("wheat", &self.wheat)
            .field("fields-width", &self.fields_width)
            .field("fields-height", &self.fields_height)
            .field("fields", &self.fields)
            .finish()
    }
}
#[repr(u8)]
#[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
pub enum LogLevel {
    Debug,
    Info,
    Warn,
    Error,
}
impl ::core::fmt::Debug for LogLevel {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
            LogLevel::Debug => f.debug_tuple("LogLevel::Debug").finish(),
            LogLevel::Info => f.debug_tuple("LogLevel::Info").finish(),
            LogLevel::Warn => f.debug_tuple("LogLevel::Warn").finish(),
            LogLevel::Error => f.debug_tuple("LogLevel::Error").finish(),
        }
    }
}
impl LogLevel {
    #[doc(hidden)]
    pub unsafe fn _lift(val: u8) -> LogLevel {
        if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
        }
        match val {
            0 => LogLevel::Debug,
            1 => LogLevel::Info,
            2 => LogLevel::Warn,
            3 => LogLevel::Error,
            _ => panic!("invalid enum discriminant"),
        }
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn sell(sell: Sellable, amount: u32) -> Result<(), _rt::String> {
    unsafe {
        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
        struct RetArea(
            [::core::mem::MaybeUninit<u8>; 3 * ::core::mem::size_of::<*const u8>()],
        );
        let mut ret_area = RetArea(
            [::core::mem::MaybeUninit::uninit(); 3 * ::core::mem::size_of::<*const u8>()],
        );
        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "sell"]
            fn wit_import1(_: i32, _: i32, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import1(sell.clone() as i32, _rt::as_i32(&amount), ptr0) };
        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
        let result6 = match l2 {
            0 => {
                let e = ();
                Ok(e)
            }
            1 => {
                let e = {
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l4 = *ptr0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    _rt::string_lift(bytes5)
                };
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        };
        result6
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn buy(buy: Buyable, amount: u32) -> Result<(), _rt::String> {
    unsafe {
        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
        struct RetArea(
            [::core::mem::MaybeUninit<u8>; 3 * ::core::mem::size_of::<*const u8>()],
        );
        let mut ret_area = RetArea(
            [::core::mem::MaybeUninit::uninit(); 3 * ::core::mem::size_of::<*const u8>()],
        );
        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "buy"]
            fn wit_import1(_: i32, _: i32, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import1(buy.clone() as i32, _rt::as_i32(&amount), ptr0) };
        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
        let result6 = match l2 {
            0 => {
                let e = ();
                Ok(e)
            }
            1 => {
                let e = {
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l4 = *ptr0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    _rt::string_lift(bytes5)
                };
                Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
        };
        result6
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn bot_action(action: Action) -> () {
    unsafe {
        let (result0_0, result0_1) = match action {
            Action::Idle => (0i32, 0i32),
            Action::MoveLeft => (1i32, 0i32),
            Action::MoveRight => (2i32, 0i32),
            Action::MoveUp => (3i32, 0i32),
            Action::MoveDown => (4i32, 0i32),
            Action::Water => (5i32, 0i32),
            Action::Seed(e) => (6i32, e.clone() as i32),
            Action::Harvest => (7i32, 0i32),
        };
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "bot-action"]
            fn wit_import1(_: i32, _: i32);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import1(_: i32, _: i32) {
            unreachable!()
        }
        unsafe { wit_import1(result0_0, result0_1) };
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn update_display_name(display_name: &str) -> () {
    unsafe {
        let vec0 = display_name;
        let ptr0 = vec0.as_ptr().cast::<u8>();
        let len0 = vec0.len();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "update-display-name"]
            fn wit_import1(_: *mut u8, _: usize);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import1(_: *mut u8, _: usize) {
            unreachable!()
        }
        unsafe { wit_import1(ptr0.cast_mut(), len0) };
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn get_farm() -> FarmState {
    unsafe {
        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
        struct RetArea(
            [::core::mem::MaybeUninit<u8>; 16 + 2 * ::core::mem::size_of::<*const u8>()],
        );
        let mut ret_area = RetArea(
            [::core::mem::MaybeUninit::uninit(); 16
                + 2 * ::core::mem::size_of::<*const u8>()],
        );
        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "get-farm"]
            fn wit_import1(_: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import1(_: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import1(ptr0) };
        let l2 = *ptr0.add(0).cast::<i32>();
        let l3 = *ptr0.add(4).cast::<i32>();
        let l4 = *ptr0.add(8).cast::<i32>();
        let l5 = *ptr0.add(12).cast::<i32>();
        let l6 = *ptr0.add(16).cast::<*mut u8>();
        let l7 = *ptr0.add(16 + 1 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
        let base30 = l6;
        let len30 = l7;
        let mut result30 = _rt::Vec::with_capacity(len30);
        for i in 0..len30 {
            let base = base30.add(i * (2 * ::core::mem::size_of::<*const u8>()));
            let e30 = {
                let l8 = *base.add(0).cast::<*mut u8>();
                let l9 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                let base29 = l8;
                let len29 = l9;
                let mut result29 = _rt::Vec::with_capacity(len29);
                for i in 0..len29 {
                    let base = base29
                        .add(i * (16 + 3 * ::core::mem::size_of::<*const u8>()));
                    let e29 = {
                        let l10 = i32::from(*base.add(0).cast::<u8>());
                        let l14 = i32::from(*base.add(16).cast::<u8>());
                        let l15 = i32::from(*base.add(17).cast::<u8>());
                        let l16 = *base
                            .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                            .cast::<*mut u8>();
                        let l17 = *base
                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                            .cast::<usize>();
                        let base28 = l16;
                        let len28 = l17;
                        let mut result28 = _rt::Vec::with_capacity(len28);
                        for i in 0..len28 {
                            let base = base28
                                .add(i * (8 + 6 * ::core::mem::size_of::<*const u8>()));
                            let e28 = {
                                let l18 = *base.add(0).cast::<*mut u8>();
                                let l19 = *base
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len20 = l19;
                                let bytes20 = _rt::Vec::from_raw_parts(
                                    l18.cast(),
                                    len20,
                                    len20,
                                );
                                let l21 = i32::from(
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l25 = i32::from(
                                    *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l26 = *base
                                    .add(4 + 5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                let l27 = *base
                                    .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                Entity {
                                    id: _rt::string_lift(bytes20),
                                    display_name: match l21 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l22 = *base
                                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l23 = *base
                                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len24 = l23;
                                                let bytes24 = _rt::Vec::from_raw_parts(
                                                    l22.cast(),
                                                    len24,
                                                    len24,
                                                );
                                                _rt::string_lift(bytes24)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    entity_type: EntityType::_lift(l25 as u8),
                                    position: Position {
                                        x: l26 as u32,
                                        y: l27 as u32,
                                    },
                                }
                            };
                            result28.push(e28);
                        }
                        _rt::cabi_dealloc(
                            base28,
                            len28 * (8 + 6 * ::core::mem::size_of::<*const u8>()),
                            ::core::mem::size_of::<*const u8>(),
                        );
                        Field {
                            plant: match l10 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l11 = i32::from(*base.add(4).cast::<u8>());
                                        let l12 = *base.add(8).cast::<i32>();
                                        let l13 = *base.add(12).cast::<i32>();
                                        Plant {
                                            plant_type: PlantType::_lift(l11 as u8),
                                            growth_stage: l12 as u32,
                                            growth_stage_max: l13 as u32,
                                        }
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            watered: _rt::bool_lift(l14 as u8),
                            field_type: FieldType::_lift(l15 as u8),
                            entities: result28,
                        }
                    };
                    result29.push(e29);
                }
                _rt::cabi_dealloc(
                    base29,
                    len29 * (16 + 3 * ::core::mem::size_of::<*const u8>()),
                    ::core::mem::size_of::<*const u8>(),
                );
                result29
            };
            result30.push(e30);
        }
        _rt::cabi_dealloc(
            base30,
            len30 * (2 * ::core::mem::size_of::<*const u8>()),
            ::core::mem::size_of::<*const u8>(),
        );
        let result31 = FarmState {
            grass: l2 as u32,
            wheat: l3 as u32,
            fields_width: l4 as u32,
            fields_height: l5 as u32,
            fields: result30,
        };
        result31
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn get_bot_state(id: &str) -> BotState {
    unsafe {
        #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
        #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
        struct RetArea(
            [::core::mem::MaybeUninit<u8>; 24 + 4 * ::core::mem::size_of::<*const u8>()],
        );
        let mut ret_area = RetArea(
            [::core::mem::MaybeUninit::uninit(); 24
                + 4 * ::core::mem::size_of::<*const u8>()],
        );
        let vec0 = id;
        let ptr0 = vec0.as_ptr().cast::<u8>();
        let len0 = vec0.len();
        let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "get-bot-state"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
            unreachable!()
        }
        unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
        let l3 = *ptr1.add(0).cast::<*mut u8>();
        let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
        let len5 = l4;
        let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
        let l6 = *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l7 = *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>();
        let len8 = l7;
        let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
        let l9 = i32::from(
            *ptr1.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
        );
        let v11 = match l9 {
            0 => Action::Idle,
            1 => Action::MoveLeft,
            2 => Action::MoveRight,
            3 => Action::MoveUp,
            4 => Action::MoveDown,
            5 => Action::Water,
            6 => {
                let e11 = {
                    let l10 = i32::from(
                        *ptr1
                            .add(1 + 4 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    PlantType::_lift(l10 as u8)
                };
                Action::Seed(e11)
            }
            n => {
                debug_assert_eq!(n, 7, "invalid enum discriminant");
                Action::Harvest
            }
        };
        let l12 = *ptr1.add(4 + 4 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
        let l13 = *ptr1.add(8 + 4 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
        let l14 = *ptr1.add(12 + 4 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
        let l15 = *ptr1.add(16 + 4 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
        let l16 = *ptr1.add(20 + 4 * ::core::mem::size_of::<*const u8>()).cast::<i32>();
        let result17 = BotState {
            id: _rt::string_lift(bytes5),
            display_name: _rt::string_lift(bytes8),
            current_action: v11,
            energy: l12 as u32,
            water: l13 as u32,
            seeds: l14 as u32,
            position: Position {
                x: l15 as u32,
                y: l16 as u32,
            },
        };
        result17
    }
}
#[allow(unused_unsafe, clippy::all)]
pub fn log(message: &str, level: LogLevel) -> () {
    unsafe {
        let vec0 = message;
        let ptr0 = vec0.as_ptr().cast::<u8>();
        let len0 = vec0.len();
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "$root")]
        unsafe extern "C" {
            #[link_name = "log"]
            fn wit_import1(_: *mut u8, _: usize, _: i32);
        }
        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import1(_: *mut u8, _: usize, _: i32) {
            unreachable!()
        }
        unsafe { wit_import1(ptr0.cast_mut(), len0, level.clone() as i32) };
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_tick_cabi<T: Guest>(
    arg0: *mut u8,
    arg1: usize,
    arg2: *mut u8,
    arg3: usize,
    arg4: i32,
    arg5: i32,
    arg6: i32,
    arg7: i32,
    arg8: i32,
    arg9: i32,
    arg10: i32,
) {
    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    let len1 = arg3;
    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
    let v2 = match arg4 {
        0 => Action::Idle,
        1 => Action::MoveLeft,
        2 => Action::MoveRight,
        3 => Action::MoveUp,
        4 => Action::MoveDown,
        5 => Action::Water,
        6 => {
            let e2 = PlantType::_lift(arg5 as u8);
            Action::Seed(e2)
        }
        n => {
            debug_assert_eq!(n, 7, "invalid enum discriminant");
            Action::Harvest
        }
    };
    T::tick(BotState {
        id: _rt::string_lift(bytes0),
        display_name: _rt::string_lift(bytes1),
        current_action: v2,
        energy: arg6 as u32,
        water: arg7 as u32,
        seeds: arg8 as u32,
        position: Position {
            x: arg9 as u32,
            y: arg10 as u32,
        },
    });
}
pub trait Guest {
    fn tick(bot: BotState) -> ();
}
#[doc(hidden)]
macro_rules! __export_world_wasm_farmer_bot_cabi {
    ($ty:ident with_types_in $($path_to_types:tt)*) => {
        const _ : () = { #[unsafe (export_name = "tick")] unsafe extern "C" fn
        export_tick(arg0 : * mut u8, arg1 : usize, arg2 : * mut u8, arg3 : usize, arg4 :
        i32, arg5 : i32, arg6 : i32, arg7 : i32, arg8 : i32, arg9 : i32, arg10 : i32,) {
        unsafe { $($path_to_types)*:: _export_tick_cabi::<$ty > (arg0, arg1, arg2, arg3,
        arg4, arg5, arg6, arg7, arg8, arg9, arg10) } } };
    };
}
#[doc(hidden)]
pub(crate) use __export_world_wasm_farmer_bot_cabi;
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
    pub use alloc_crate::alloc;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_wasm_farmer_bot_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: __export_world_wasm_farmer_bot_cabi!($ty with_types_in
        $($path_to_types_root)*);
    };
}
#[doc(inline)]
pub(crate) use __export_wasm_farmer_bot_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:tessenow:wasm-farmer:wasm-farmer-bot:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1055] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x99\x07\x01A\x02\x01\
A0\x01m\x02\x05wheat\x05grass\x03\0\x0aplant-type\x03\0\0\x01r\x03\x0aplant-type\
\x01\x0cgrowth-stagey\x10growth-stage-maxy\x03\0\x05plant\x03\0\x02\x01q\x08\x04\
idle\0\0\x09move-left\0\0\x0amove-right\0\0\x07move-up\0\0\x09move-down\0\0\x05w\
ater\0\0\x04seed\x01\x01\0\x07harvest\0\0\x03\0\x06action\x03\0\x04\x01m\x02\x05\
grass\x05wheat\x03\0\x08sellable\x03\0\x06\x01m\x03\x05water\x05seeds\x06energy\x03\
\0\x07buyable\x03\0\x08\x01r\x02\x01xy\x01yy\x03\0\x08position\x03\0\x0a\x01r\x07\
\x02ids\x0cdisplay-names\x0ecurrent-action\x05\x06energyy\x05watery\x05seedsy\x08\
position\x0b\x03\0\x09bot-state\x03\0\x0c\x01m\x01\x03bot\x03\0\x0bentity-type\x03\
\0\x0e\x01ks\x01r\x04\x02ids\x0cdisplay-name\x10\x0bentity-type\x0f\x08position\x0b\
\x03\0\x06entity\x03\0\x11\x01m\x03\x05owned\x07unowned\x05stone\x03\0\x0afield-\
type\x03\0\x13\x01k\x03\x01p\x12\x01r\x04\x05plant\x15\x07watered\x7f\x0afield-t\
ype\x14\x08entities\x16\x03\0\x05field\x03\0\x17\x01p\x18\x01p\x19\x01r\x05\x05g\
rassy\x05wheaty\x0cfields-widthy\x0dfields-heighty\x06fields\x1a\x03\0\x0afarm-s\
tate\x03\0\x1b\x01m\x04\x05debug\x04info\x04warn\x05error\x03\0\x09log-level\x03\
\0\x1d\x01j\0\x01s\x01@\x02\x04sell\x07\x06amounty\0\x1f\x03\0\x04sell\x01\x20\x01\
@\x02\x03buy\x09\x06amounty\0\x1f\x03\0\x03buy\x01!\x01@\x01\x06action\x05\x01\0\
\x03\0\x0abot-action\x01\"\x01@\x01\x0cdisplay-names\x01\0\x03\0\x13update-displ\
ay-name\x01#\x01@\0\0\x1c\x03\0\x08get-farm\x01$\x01@\x01\x02ids\0\x0d\x03\0\x0d\
get-bot-state\x01%\x01@\x02\x07messages\x05level\x1e\x01\0\x03\0\x03log\x01&\x01\
@\x01\x03bot\x0d\x01\0\x04\0\x04tick\x01'\x04\0$tessenow:wasm-farmer/wasm-farmer\
-bot\x04\0\x0b\x15\x01\0\x0fwasm-farmer-bot\x03\0\0\0G\x09producers\x01\x0cproce\
ssed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
